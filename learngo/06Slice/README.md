# 슬라이스란?
슬라이스는 자체적으로 데이터를 저장하지는 않으며
단지 내부배열의 원소에 대한 뷰일 뿐입니다. 슬라이스는 슬라이드에 들어있는 내용물에 초점을 맞추는 현미경에 비유할 수 있습니다.

내부 배열의 슬라이스를 사용하면 슬라이스를 통해 노출되는 내부배열 원소의 일부만 "볼" 수 있습니다.
```go
array1 := [5]string{"a","b","c","d","e"}
slice1 := array1[:3]
fmt.Println(slice1)
```
```zsh
[a b c]
```
```go
array2 := [5]string{"f","g","h","i","j"}
slice2 := array2[2:5]
fmt.Println(slice2)
```
```zsh
[h i j]
```
여러 슬라이스가 동일한 내부 배열을 가리킬 수도 있습니다. 각 슬라이스는 자체적으로 내부 배열의 원소의 하위 집합에 대한 뷰가 되며, 서로 포함되는 원소가 겹칠 수도 있습니다.
```go
array3 := [5]string{"a","b","c","d","e"}
slice3 := array1[:3]
slice4 := array1[2:5]
fmt.Println(slice3, slice4)
```
```zsh
[a b c] [c d e]
```
# 내부 배열을 변경하면 슬라이스도 변경됩니다.
슬라이스를 다룰 때에는 주의해야 할 것이 있습니다. 슬라이스는 단지 배열 데이터에 대한 뷰이기 때문에 내부 배열을 변경하면 슬라이스에도 변경된 값이 반영됩니다.
```go
array1 := [5]string{"a","b","c","d","e"}
slice1 := array1[:3]
slice2 := array1[2:5]
array1[2] = "X"
fmt.Println(array1)
fmt.Println(slice1, slice2)
```
```zsh
[a b X d e]
[a b X] [X d e]
```
여러 슬라이스가 동일한 내부 배열을 가리키고 있을 대 내부 배열의 원소 값을 변경하면 모든 슬라이스에 변경사항이 적용됨을 볼 수 있습니다.

이러한 잠재적인 문제 때문에 일반적으로 배열을 먼저 만들고 슬라이스 연산자를 사용하는 방법보다는 make나 슬라이스 리터럴을 사용해 슬라이스를 만드는 방법이 더 낫습니다. make나 슬라이스 리터럴을 사용하면 내부 배열을 건드릴 일이 전혀 없기 때문이죠.