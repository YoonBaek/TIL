# go 문은 반환 값과 함께 사용할 수 없습니다.
고루틴으로의 전환은 또 다른 문제를 야기합니다. go문에는 반환 값을 가진 함수를 사용할 수 없습니다. 페이지의 크기를 직접 출력하는 대신 값으로 반환하도록 responseSize 함수를 변경하는 상황을 가정해보도록 합시다.
```go
func main() {
    var size int
    for _, url := range urls {
		size = go responseSize(url)
        fmt.Println(size)
	}
}
```
이 코드는 완전히 잘못되었습니다. 이 코드의 결과는 아래와 같습니다.
```
syntax error : unexpected go, expecting expression
```
위와 같은 컴파일 에러가 발생합니다. 컴파일러는 go문으로 호출하고 있는 함수로부터 반환 값을 가져오고 있는 지점에서 컴파일을 중단합니다.

이는 아주 적절한 에러입니다. go문으로 호출한다는 것은 새로운 별도의 고루틴을 생성해서 같이 실행하겠다는 뜻인데, responseSize함수는 웹사이트의 응답을 기다려야하기 때문에 값을 즉시 반환하지 않습니다. 하지만 main 고루틴 코드는 아직 존재하지도 않는 반환 값을 즉시 반환 받기를 기대하고 있습니다.

이는 responseSize와 같이 실행시간이 긴 함수뿐만 아니라 go문으로 실행되는 모든 함수에 동일하게 적용되는 규칙입니다. 언제 준비될지 모르는 반환 값에 의존할 수는 없으므로 Go컴파일러는 애초에 반환값을 사용하려는 시도 자체를 차단하는 것입니다.

Go에서는 go문으로 호출된 함수의 반환 값을 사용할 수 없는데, 반환하려는 값이 사용하려는 시점보다 먼저 준비될 것임을 보장할 수 없기 때문입니다.
```go
func greeting() string {
    return "hello"
}

func main() {
    // 아직 준비되지 않은 반환 값을 즉시 사용하려는 시도.
    fmt.Println(go greeting()) 
}
```
# 채널
하지만 Go에는 고루틴끼리 통신을 할 수 있는 방법이 존재하는데, 바로 **채널(channel)**입니다. 채널을 사용하면 한 고루틴에서 다른 고루틴으로 값을 전달할 수 있을 뿐만 아니라 수신 고루틴이 값을 사용하기 전에 송신 고루틴이 값을 보냈음을 보장할 수 있습니다.

채널을 사용해 볼 실용적인 방법으로 유일한 것은 한 고루틴에서 또 다른 고루틴으로 직접 통신을 해 보는 것입니다. 채널을 사용하려면 우선 다음 세 작업을 할 수 있어야 합니다.
* 채널 생성하기.
* 채널을 매개변수로 받는 함수 작성하기. 이 함수는 별도의 고루틴에서 실행하여 채널에 값을 전달하도록 함.
* 고루틴에서 채널을 총해 전달한 값 수신하기.

각 채널은 특정 타입의 값만 주고받을 수 있기 때문에 int값을 갖는 하나의 채널과 구조체 타입을 갖는 또 다른 채널처럼 별도의 채널들을 가질 수 있습니다. 채널 변수를 선언하기 위해서는 chan 키워드 다음으로 채널이 주고받을 값의 타입을 지정해 주면 됩니다.
```go
var myChannel chan float64
```
실제로 사용할 수 있는 채널을 생성하려면 맵과 슬라이스 생성과 동일하게 make 함수를 사용해야 합니다. make 함수에는 생성할 채널의 타입만 전달해 주면 됩니다(채널을 할당할 변수와 동일한 타입이어야 합니다.)
```go
myChannel = make(chan float64)
```
채널 변수를 별도로 선언하는 것보다는 대부분의 경우 단축 변수 선언을 사용하는 것이 더 간편합니다.
```go
myChannel := make(chan float64)
```
# 채널을 통해 값 주고 받기
채널에 값을 전달할 때는 <- 연산자를 사용합니다. 이는 보내는 값이 보낼 채널을 가리키는 것처럼 보입니다.
```go
// 값을 보낼 채널 / 연산자 / 채널을 통해 보낼 값
myChannel <- 3.14
```
채널에서 값을 받아올 때에도 마찬가지로 <- 연산자를 사용하지만, 화살표의 위치가 다르며 이번에는 화살표가 값을 가져올 채널의 왼쪽에 위치합니다. 이 때는 채널에서 값을 빼오는 것 처럼 보입니다.
```go
variable <- myChannel
```
main 함수에서는 make함수를 사용해 greting으로 전달할 채널을 생성한 다음 greeting을 새로운 고루틴으로 호출합니다. 여기서 핵심은 별도의 고루틴을 사용한다는 것인데, 채널의 경우 고루틴 간의 통신에서만 사용할 수 있기 때문입니다. 마지막으로 greeting으로 전달한 채널에서 문자열 값을 가져와 출력합니다.
```go
func greeting(myChannel chan string) {
    myChannel <- "Hi!"
}

func main() {
    myChannel := make(chan string)
    go greeting(myChannel)
    fmt.Println(<-myChannel)
} 
```
```
Hi!
```
채널에서 가져온 값을 Println으로 바로 전달할 필요는 없습니다. 채널에서 가져온 값은 값이 필요한 모든 곳에서 사용할 수 있습니다.(즉, 변수나 함수의 반환 값으로도 사용할 수 있습니다.) 예를 들어, 위 예제에서는 채널에서 받아온 값을 변수에 먼저 할당할 수 있습니다.
```go
// 수신한 값을 변수에 저장할 수도 있습니다.
receivedValue := <-myChannel
fmt.Println(receivedValue)
```

# 채널을 사용한 고루틴 동기화
이전에 채널은 수신 고루틴이 값을 사용하기 전에 송신 고루틴이 값을 보냈음을 보장할 수 있다고 말한 적이 있습니다. 채널은 현재 고루틴의 모든 작업을 중지하는 **블로킹(Blocking)**으로 이를 보장할 수 있습니다. 어떤 채널에 대한 송신 연산은 다른 고루틴이 해당 채널에서 값을 가져가기 전까지 송신 고루틴을 블로킹합니다. 그 반대도 마찬가지인데, 수신 연산은 다른 고루틴이 해당 채널에 값을 보내기 전 까지 수신 고루틴을 블로킹합니다. 이러한 동작 방식을 통해 고루틴은 자기 자신의 행동을 **동기화(synchronize)**할 수 있습니다. 즉, 자신의 실행 타이밍을 조정할 수 있습니다.

다음 프로그램은 두 개의 채널을 생성하고 각 채널을 두 개의 새로운 고루틴으로 전달하고 있습니다. 그리고 main 고루틴에서는 두 채널에서 받아온 값을 출력하고 있습니다. "a"와 "b"를 반복적으로 출력한 고루틴과는 달리 이 프로그램의 출력값은 예측 가능하며 항상 a,b,c,d,e,f의 값으로 출력됩니다.

# 이해한 것 정리
고루틴은 동시간에 실행될 수 있는 또 다른 main이라고 보면 편하다.  
고루틴을 켜지 않으면 main에 불과하다.
즉, 메인 고루틴에서 수신을 한다면 메인 고루틴 밖에서 송신을 해야한다.  
채널을 왜 쓰냐면... 다른 고루틴 끼리 통신을 하기 위해 쓰는 것이기 때문이다.  
